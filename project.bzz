#Modified the exisiting buzz code for square lattice using 2 swarm groups
# We need this for 2D vectors
# Make sure you pass the correct include path to "bzzc -I <path1:path2> ..."
include "include/vec2.bzz"

# Lennard-Jones parameters
TARGET_KIN_SQ     = 40#283.0 #d*root2
EPSILON_KIN_SQ    = 1000#150.0
TARGET_NONKIN_SQ  = 28#200.0 #d
EPSILON_NONKIN_SQ = 500#100.0

TARGET_KIN_CL     = 70#200.0 #d 	increased otherwise blue doesn't form proper big circle
EPSILON_KIN_CL    = 1000#150.0
TARGET_NONKIN_CL  = 60#500.0 #D 
EPSILON_NONKIN_CL = 500#100.0

# Weightage on light readings
LIGHT_SCALE_SQ = 3
LIGHT_SCALE_CL = 2

# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
  return -(epsilon / dist) * ((target / dist)^4 - (target / dist)^2)
}

# Neighbor data to LJ interaction vector
function lj_vector_kin(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_KIN_SQ, EPSILON_KIN_SQ), data.azimuth)
}

# Neighbor data to LJ interaction vector
function lj_vector_nonkin(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_NONKIN_SQ, EPSILON_NONKIN_SQ), data.azimuth)
}

# Neighbor data to LJ interaction vector
function lj_vector_kin_cl(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_KIN_CL, EPSILON_KIN_CL), data.azimuth)
}

# Neighbor data to LJ interaction vector
function lj_vector_nonkin_cl(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET_NONKIN_CL, EPSILON_NONKIN_CL), data.azimuth)
}

# Accumulator of neighbor LJ interactions
function lj_sum(rid, data, accum) {
  return math.vec2.add(data, accum)
}

# Converting the sensor readings to cartesian format
function reading2vec(rid, reading){
    return math.vec2.newp(reading.value, reading.angle)
}

#Get the vector towards the light source
function follow_light() {
	var light_vector = math.vec2.new(0.0, 0.0)
  cart = map(light, reading2vec)
  light_vector = reduce(cart, lj_sum, light_vector)
	#math.vec2.norm(light_vector)

	return light_vector
}

# For square lattice formation
function square() {
	var temp = follow_light()
 	math.vec2.scale(temp, LIGHT_SCALE_SQ) # scaling the light vector for faster aggregation

  # Calculate accumulator
  var accum = neighbors.kin().map(lj_vector_kin).reduce(lj_sum, math.vec2.new(0.0, 0.0))
  accum = neighbors.nonkin().map(lj_vector_nonkin).reduce(lj_sum, accum)
  if(neighbors.count() > 0)
    math.vec2.scale(accum, 1.0 / neighbors.count())

	accum = math.vec2.add(temp, accum)

  # Move according to vector
  goto(accum.x, accum.y)
}

# For outer cell formation
function cell(){
  var temp = follow_light()
 	math.vec2.scale(temp, LIGHT_SCALE_CL)

	var accum = neighbors.kin().map(lj_vector_kin_cl).reduce(lj_sum, math.vec2.new(0.0, 0.0) )
  accum = neighbors.nonkin().map(lj_vector_nonkin_cl).reduce(lj_sum, accum)

	if(neighbors.count() > 0)
    math.vec2.scale(accum, 1.0 / neighbors.count())


	accum = math.vec2.add(temp, accum)

  # Move according to vector
  goto(accum.x, accum.y)
}

# Executed at init time
function init() {
  # Divide the swarm in three sub-swarms
  s1 = swarm.create(1)
	s1.select(id % 3 == 0)

	#s2 = s1.others(2)
	s2 = swarm.create(2)
	s2.select((id+1) % 3 == 0)

	s3 = swarm.create(3)
	s3.select((id+2) % 3 == 0)

	if (s1.in()){ set_leds(255,0,0) }
	if (s2.in()){ set_leds(0,255,0) }
	if (s3.in()){ set_leds(0,0,255) }
}

# Executed every time step
function step() {
  s1.exec(square)
  s2.exec(square)
	s3.exec(cell)


}

# Execute at exit
function destroy() {
}
