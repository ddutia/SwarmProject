
include "include/vec2.bzz"
include "explore.bzz"

# Threshold to detect obstacle
delta = 0.1
left_ws = 5.0
right_ws = 5.0
pi = 22.0/7.0
tol = 1 #degree tolerance


function rad2deg(angle){
	deg = angle*180/pi
	return deg
}

function deg2rad(angle){
	rad = angle*pi/180
	return rad
}


# Accumulator of neighbor LJ interactions
function lj_sum(rid, data, accum) {
  return math.vec2.add(data, accum)
}

function reading2vec(rid, reading){
    return math.vec2.newp(reading.value, reading.angle)
}

# Accumulate proximity readings
function get_range() {
	var range = math.vec2.new(0.0, 0.0)
  cart = map(proximity, reading2vec)
  range = reduce(cart, lj_sum, range)

	return range
}

############################################################################################################
#### PROBLEM HERE#####################
# The bots keep on rotating
function c_randomwalk(rid, theta_prev){
	rho = 0.7  #math.rng.uniform(0.0,1.0)
	#log(rho)
  mu = 0.0
	a = math.cos(theta_prev - mu)
	theta = (1-rho^2)/((2*pi)*(1+ rho^2 - 2*rho*a))
	log(rad2deg(theta))
	#gotoc(math.sin(theta),math.cos(theta))

	if (rad2deg(theta_prev)> (rad2deg(theta)-tol) and rad2deg(theta_prev)<(rad2deg(theta)+tol)){
		#gotoc(math.sin(theta), math.cos(theta))
		#gotoc(0, 0)
		set_wheels(left_ws, right_ws)
		}
	else {
		  #gotoc(math.sin(theta),math.cos(theta))
			set_wheels(1.0, -1.0)
	}

}

###############################################################################################

#Obstacle avoidance
function avoid(){
	stepsize = 100
	accum = get_range()
	len = math.vec2.length(accum)
	ang = math.vec2.angle(accum)
	#log(ang)

	theta_prev = pose.orientation.yaw

	#If theres a obstacle as detected by proximity sensor >0, turn the direction
	if (len < delta){
		#log(rad2deg(theta_prev))
		
		##############   Would be called at init and afterwards depending on the stepsize###########
		if ( (counter<0) or (counter > stepsize) ){
			c_randomwalk(rid, theta_prev)
			counter = 0
		}
		else{
			
			counter = counter + 1
			}
}
	 

	else if (ang > 0.0){
		set_wheels(left_ws, 0.0)   }
		else {
			set_wheels(0.0, right_ws) }
}

function whereami(){

	posx = pose.position.x
	posy = pose.position.y


	vid = find_vid(posx,posy)
	#log(vid)
	if(ini==0){
	vid_prev = vid
	update(vid)
	ini = 1
	}

	if((vid_prev - vid) != 0){
		update(vid)
		vid_prev = vid}


}

function init() {

	s1 = swarm.create(1)
	s1.join()
	create_vstig()

	counter = -1
  ini = 0

}


function step() {
	s1.exec(avoid)
	
	s1.exec(whereami)
}


function reset() {
}


function destroy() {
}
